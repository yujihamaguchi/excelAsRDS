(use '[clojure.data.json :as json :only [read-str write-str]])
(set [])
(json/write-str (set []))
(json/read-str "[]")
(when nil "true")
(when true "true")
(when [] "true")
(use '[clojure.test])
(doc is)
(is (= 1 1))
(is (odd? 1))
(is (odd? 2))
(is (and true false))
(is (and true true))
(find-doc #"^re")
(find-doc #"re[^a-z]")
(find-doc #"^re-")
(load-schema-info "./test01.js")
(load-schema-info "./test/jp/co/isidao/aorba/opss/test01.js")
 (load-schema-info "./test/jp/co/isidao/aorba/opss/test01.js")
(load-schema-info "./test/jp/co/isidao/aorba/opss/test01.js")
(doc json/read-str)
(load-schema-info "./test/jp/co/isidao/aorba/opss/test01.js")
(set [1 2 3])
(load-schema-info "./test/jp/co/isidao/aorba/opss/test01.json")
(load-schema-info "./test/jp/co/isidao/aorba/opss/test01.sch")
(load-schema-info "./test/jp/co/isidao/aorba/opss/test01.json")
(load-schema-info "./test/jp/co/isidao/aorba/opss/not-exists.json")
(try (load-schema-info "./test/jp/co/isidao/aorba/opss/not-exists.json") (catch Exception e (.getName (class e))))
(load-schema-info "./test/jp/co/isidao/aorba/opss/test05.json")
(jp.co.isidao.aorba.opss.AOSMSException.)
*compile-path*
(compile 'jp.co.isidao.aorba.opss.AORBAException)
(jp.co.isidao.aorba.opss.AORBAException.)
(meet-where-clause-cond {:col-idx-map {:attr1 0 :attr2 1 :attr3 2} :required []} sheet 3)
(meet-where-clause-cond {:col-idx-map {:attr1 0 :attr2 1 :attr3 2} :required []} "sheet" 3)
(== 1 1.0)
(== "abc" "abc")
(getCellValues "./test/jp/co/isidao/aorba/opss/test01.xls" 0 "[0,1]")
(getCellValues "./test/jp/co/isidao/aorba/opss/test01.xls" 0 "[[0,1]]"
)
(getCellValues "./test/jp/co/isidao/aorba/opss/test01.xls" 0 "[[0,1]]")
(int? 1)
(number? 1)
(is-valid-cell-addr-lst "")
[1 2]
(count [1 2])
(count [[1 2]])
(seq? [1 2])
(list? [1 2])
(vector? [1 2])
(seq [1 2](
))
(seq [1 2])
(int? 1)
(is-valid-cell-addr-val-lst "[[1,2,3],[3,4,\"x\"]]")
(json/read-json "[[1,2,3],[3,4,\"x\"]]")
(def kvs (json/read-json "[[1,2,3],[3,4,\"x\"]]"))
kvs
(vector? kvs)
(<= 1 (count kvs))
(every? vector? kvs)
(every? #(= 3 (count %)) kvs)
(every? #(every? integer? %) (take 2 kvs))))
(every? #(every? integer? %) (take 2 kvs))
(doc doseq)
(doseq #(* 2 %) [1 2 3])
(find-doc #"^do")
(doseq #(* 2 %) (seq [1 2 3]))
(seq [1 2 3])
(doseq #(* 2 %) '(1 2 3))
(doseq #(* 2 %) [1 2 3])
(doc for)
(doc do)
(find-doc #"^map")
(find-doc "return nil")
(doc doseq)
(find-doc "Returns nil")
(third '(1 2 3))
(nth 3 '(1 2 3))
(nth '(1 2 3) 3)
(nth '(1 2 3) 2)
(doc with-open)
(let [{wb :in} {:in "xxx" :out "yyy"}] wb)
(get-workbook "./test/jp/co/isidao/aorba/opss/test01.xls")
(update-excel "./test/jp/co/isidao/aorba/opss/tmp.xls")
(doc with-open)
(code with-open)
(source with-open)
#{1 1 2}
[ { id: 'la0001', pwd: 'xxx' },
  { id: 'la0002', pwd: 'yyy' } ]
(def x [ { id: 'la0001', pwd: 'xxx' },{ id: 'la0002', pwd: 'yyy' } ])
(json/read-json "[ { \"id\" : \"x\", \"pwd\" : \"p1\" }, { \"id\" : \"y\", \"pwd\" : \"p2\" }]")
(def x (json/read-json "[ { \"id\" : \"x\", \"pwd\" : \"p1\" }, { \"id\" : \"y\", \"pwd\" : \"p2\" }]"))
x
(def y "{"\id\" : 0, \"pwd\" : 1}")
(def y (json/read-json "{"\id\" : 0, \"pwd\" : 1}"))
(json/read-json "{ \"id\" : 0, \"pwd\" : 1 }")
(def y (json/read-json "{ \"id\" : 0, \"pwd\" : 1 }"))
y
x
((fn [m] (keys m)) (first x))
(doc key)
(key {1:2})
(key x)
(key (first x))
(first x)
(first (first x))
(key (first (first x)))
x
y
(range 3 5)
(doc filter)
(doc complement)
(doc deftest)
(doc is)
(use 'clojure.test)
(doc is)
{:pwd "p11", :whereClause {:id "x"}}
(set x {:pwd "p11", :whereClause {:id "x"}})
(let [kvm {:pwd "p11", :whereClause {:id "x"}}] (set (keys (dissoc kvm :whereClause))))
(let [kvm {:pwd "p11", :whereClause {:id "x"}}] (set (keys (kvm :whereClause))))
(use 'clojure.test)
(doc deftest)
(use 'clojure.java.io)
(doc copy)
(doc delete-file)
(source delete-file)
(doc select-keys)
(find-doc "Returns a map")
(let [x {id: "x", pwd: "p1"}] x)
(let [x {:id "x", :pwd "p1"}] x)
(let [x {:id "x", :pwd "p1"}] (filter #(empty? (val %)) x))
(let [x {:id "", :pwd "p1"}] (filter #(empty? (val %)) x))
(let [x {:id "", :pwd ""}] (filter #(empty? (val %)) x))
(let [x {:id "", :pwd ""}] (keys (filter #(empty? (val %)) x)))
(let [x {:id "", :pwd ""}] (set (keys (filter #(empty? (val %)) x))))
#{:pwd :id}
(= #{:pwd :id} #{:pwd :id})
(= #{:pwd :id} #{:id :pwd})
(set [ 1 2 3 ])
(set [ 1 1])
(doc deftest)
(use 'clojure.test)
*2
(doc deftest)
(doc testing)
(doc cond)
(doc condp)
(doc set)
(use 'clojure.set)
#{1 2 3}
(def x #{1 2 3})
x
(class x)
(def y #{1 2 3})
y
(class y)
(= x y)
(def z #{4 5 6})
z
(class z)
(= x z)
(def a #{1 1 2 2 3})
(def a #{3 1 2})
a
(= a x)
(use 'clojure.set)
(use 'clojure.data.json)
(use 'clojure.set)
(doc difference)
